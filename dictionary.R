#' ---
#' title: "Build Data Dictionary"
#' author:
#' - "Alex F. Bokov^[UT Health, Department of Epidemiology and Biostatistics]"
#' date: "09/14/2018"
#' ---
#'
#+ message=F,echo=F
# init ----
debug <- 0;
.projpackages <- c( 'purrr', 'dplyr' );
.globalpath <- c(list.files(patt='^global.R$',full=T)
                 ,list.files(path='scripts',patt='^global.R$',full=T)
                 ,list.files(rec=T,pattern='^global.R$',full=T)
                 ,list.files(path='..',patt='^global.R$',full=T)
                 ,list.files(path='..',rec=T,pattern='^global.R$',full=T))[1];
if(debug>0) source(.globalpath,chdir = TRUE, local=TRUE) else {
  .junk<-capture.output(source(.globalpath,chdir=TRUE, echo=FALSE, local=TRUE))};
.currentscript <- current_scriptname('dictionary.R');
#' Setting default arguments

#' Saving original file-list so we don't keep exporting functions and
#' environment variables to other scripts
.origfiles <- ls();
#+ echo=FALSE
#### read_maps ####
#' Read the mapping files
#'
#' The data dictionary generated by DataFinisher for the current data pull
map0 <- try_import(inputdata['map0']);
#' Persistent data dictionary that (hopefully) will work over multiple data
#' pulls
map1 <- try_import(inputdata['map1']);
map2 <- try_import(inputdata['map2']);
#' Patient safety indicators
psi <- try_import(inputdata['psi']);

#' Do some cleanup
map0$c_info <- !grepl('_(tf|cd|dx|mn|STATIC)$'
                      ,coalesce(map0$durablename,'STATIC'));
map0$ddomain <- coalesce(map0$ddomain,'STATIC');

#' Create code-groups (the info column only, because that's where actual codes
#' are stored)
for(ii in c('ICD9','ICD10','ICD9PCS','ICD10PCS','CPT','LOINC','NAACCR')){
  map0[[paste0('c_',tolower(ii))]] <- map0$ddomain == ii & map0$c_info;
}

#' Create a column to bind by (unstable solution, might stop working)
#map0$standard_code <- paste0(map0$ddomain,':',gsub(' - .*$','',map0$name));
map0$standard_code <- with(
  map0
  ,case_when(
    # diagnoses, procedures, labs
     toupper(ddomain) %in% c('ICD10','ICD9','CPT','LOINC','ICD9PCS','ICD10PCS'
                            ,'DX') & grepl(' - ',name) ~ 
       paste0(ddomain,':',gsub(' - .*$','',name))
    # NAACCR data elements
    ,toupper(ddomain)=='NAACCR' & grepl('^[0-9]{4}',name) ~ 
      paste0(ddomain,':',gsub('^([0-9]{4}) .*','\\1',name))
    # VA codes for drug ingredient classes (i.e. a family of related drugs) 
    ,grepl('RXCUI',toupper(ddomain)) & grepl('[A-Z]{2}[0-9]{3}[\\]{0,1}$'
                                             ,concept_path) ~ 
      paste0('VAC:',gsub('^.*([A-Z]{2}[0-9]{3})[\\]{0,1}$','\\1',concept_path))
    # RXCUI codes for specific drugs
    ,grepl('RXCUI',toupper(ddomain)) & 
      grepl('[0-9]{4}[\\]{0,1}$',concept_path) ~ 
      paste0('RXCUI:',gsub('^.*([0-9]{4})[\\]{0,1}$','\\1',concept_path))));

#' Join on map1 and add rows from map2
map3 <- left_join(map0,map1) %>% bind_rows(map2);

#' Insure no missing display names
map3$dispname_short <- with(map3,coalesce(dispname_short,dispname));

# QC ----
#' # QC warnings (if any)
#'
#' `.missing_from_response` should be empty.
.missing_from_response <- setdiff(v(c_mainresponse,dictionary=map3)
                                  ,v(c_response,dictionary=map3));
.missing_from_response;


#### write varmap.csv ####
export(map3,'varmap.csv');

#+ echo=F,eval=F
c()
