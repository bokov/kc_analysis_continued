#' ---
#' title: "Build Data Dictionary"
#' author:
#' - "Alex F. Bokov^[UT Health, Department of Epidemiology and Biostatistics]"
#' date: "09/14/2018"
#' ---
#'
#+ message=F,echo=F
# init ----
debug <- 0;
.projpackages <- c( 'purrr', 'dplyr' );
.globalpath <- c(list.files(patt='^global.R$',full=T)
                 ,list.files(path='scripts',patt='^global.R$',full=T)
                 ,list.files(rec=T,pattern='^global.R$',full=T)
                 ,list.files(path='..',patt='^global.R$',full=T)
                 ,list.files(path='..',rec=T,pattern='^global.R$',full=T))[1];
if(debug>0) source(.globalpath,chdir = TRUE, local=TRUE) else {
  .junk<-capture.output(source(.globalpath,chdir=TRUE, echo=FALSE, local=TRUE))};
.currentscript <- current_scriptname('dictionary.R');
#' Setting default arguments

#' Saving original file-list so we don't keep exporting functions and
#' environment variables to other scripts
.origfiles <- ls();
#+ echo=FALSE
#### read_maps ####
#' Read the mapping files
#'
#' The data dictionary generated by DataFinisher for the current data pull
map0 <- try_import(inputdata['map0']);
#' Persistent data dictionary that (hopefully) will work over multiple data
#' pulls
map1 <- try_import(inputdata['map1']);
map2 <- try_import(inputdata['map2']);
map3 <- try_import(inputdata['map3']);
#' Patient safety indicators
psi <- try_import(inputdata['psi']);

# cleanup ----
#' ## Do some cleanup
#' 
#' Horrible hack, but fixes the duplicated column problem
if(basename(inputdata['map0'])=='DF_kc_v5_dbb4a700_dict.csv'){
  map0 <- subset(map0,!colname %in% c('v002_Plvs_ptnts_cd', 'v002_Plvs_ptnts'));
};
map0$name <- gsub('\\[[,0-9]{1,11} facts; [,0-9]{1,11} patients\\]',''
                  , map0$name) %>% coalesce(.,map0$colname);
map0$durablename <- with(map0,coalesce(durablename,colname)) %>% tolower;
map1$durablename <- tolower(map1$durablename);
map0$c_info <- !grepl('_(tf|cd|dx|mn|num|days|date|STATIC)$',map0$durablename
                      ,coalesce(map0$durablename,'STATIC'));
map0$ddomain <- coalesce(map0$ddomain,'STATIC');

#' true-false columns
map0$c_truefalse <- grepl('_tf$',map0$durablename);

#' Create code-groups (the info column only, because that's where actual codes
#' are stored)
for(ii in c('ICD9','ICD10','ICD9PCS','ICD10PCS','CPT','LOINC','NAACCR')){
  map0[[paste0('c_',tolower(ii))]] <- map0$ddomain == ii & map0$c_info;
}

#' Create a column to bind by (unstable solution, might stop working)
#map0$standard_code <- paste0(map0$ddomain,':',gsub(' - .*$','',map0$name));
map0$standard_code <- with(
  map0
  ,case_when(
    # diagnoses, procedures, labs
     toupper(ddomain) %in% c('ICD10','ICD9','CPT','LOINC','ICD9PCS','ICD10PCS'
                            ,'DX') & grepl(' - ',name) ~ 
       paste0(ddomain,':',gsub(' - .*$','',name))
    # NAACCR data elements
    ,toupper(ddomain)=='NAACCR' & grepl('^[0-9]{4}',name) ~ 
      paste0(ddomain,':',gsub('^([0-9]{4}) .*','\\1',name))
    # VA codes for drug ingredient classes (i.e. a family of related drugs) 
    ,grepl('RXCUI',toupper(ddomain)) & grepl('[A-Z]{2}[0-9]{3}[\\]{0,1}$'
                                             ,concept_path) ~ 
      paste0('VAC:',gsub('^.*([A-Z]{2}[0-9]{3})[\\]{0,1}$','\\1',concept_path))
    # RXCUI codes for specific drugs
    ,grepl('RXCUI',toupper(ddomain)) & 
      grepl('[0-9]{4}[\\]{0,1}$',concept_path) ~ 
      paste0('RXCUI:',gsub('^.*([0-9]{4})[\\]{0,1}$','\\1',concept_path))));

#' Join on map1 and add rows from map2
#+ map4_create
map4 <- left_join_merge(map0,map1) %>% 
  left_join_merge(map3,by=c('name'='colname_long')
                  ,yysubset=alist(c_naaccr & 
                                    colname_long != 
                                    'Kidney and Renal Pelvis')) %>%
  bind_rows(map2);

map4$rename <- with(map4,coalesce(rename,varname));

map4$rename <- with(map4,ifelse(c_info,NA,rename));

# QC ----
#' # QC warnings (if any)
#'
#' Check for duplicated rows
if(nrow(map4) != nrow(map0)+nrow(map2)){
  message('Duplicated rows created in data dictionary during mapping.');
}
.duplicatedcols <- with(map4,colname[duplicated(colname)]);
#' 
#' 
if(length(map4$colname) != length(unique(map4$colname))){
  cat('The following colname values are repeated:\n');
  pander(.duplicatedcols);
}

#' Insure no missing display names
map4$dispname <- with(map4,coalesce(dispname,chartname));
map4$dispname_short <- with(map4,coalesce(dispname_short,dispname));

#' `.missing_from_response` should be empty.
.missing_from_response <- setdiff(v(c_mainresponse,dictionary=map4)
                                  ,v(c_response,dictionary=map4));
.missing_from_response;


#### write varmap.csv ####
export(map4,'varmap.csv');

#+ echo=F,eval=F
c()
